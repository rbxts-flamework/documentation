"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[9175],{421:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>c,toc:()=>i});var r=o(5893),n=o(1151);const a={title:"Decorators"},s=void 0,c={id:"modding/guides/decorators",title:"Decorators",description:"This guide is for creating a custom decorator.",source:"@site/docs/modding/guides/decorators.md",sourceDirName:"modding/guides",slug:"/modding/guides/decorators",permalink:"/docs/modding/guides/decorators",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/modding/guides/decorators.md",tags:[],version:"current",frontMatter:{title:"Decorators"},sidebar:"flamework",previous:{title:"Lifecycle Events",permalink:"/docs/modding/guides/lifecycle-events"},next:{title:"Singletons",permalink:"/docs/modding/guides/singletons"}},d={},i=[{value:"Defining the decorator",id:"defining-the-decorator",level:2},{value:"roblox-ts decorators",id:"roblox-ts-decorators",level:3},{value:"Flamework decorators",id:"flamework-decorators",level:3},{value:"Implementing the custom decorators",id:"implementing-the-custom-decorators",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"This guide is for creating a custom decorator."}),"\n",(0,r.jsx)(t.p,{children:"It is recommended to use native roblox-ts decorators unless you need Flamework behavior, such as access to the modding decorator APIs."}),"\n",(0,r.jsx)(t.h2,{id:"defining-the-decorator",children:"Defining the decorator"}),"\n",(0,r.jsx)(t.p,{children:"Flamework supports both native roblox-ts decorators and its own built-in decorator system."}),"\n",(0,r.jsxs)(t.p,{children:["roblox-ts decorators give you the most control and allow you to use things like generics or user macros, but they do not support the following Modding APIs: listeners, ",(0,r.jsx)(t.code,{children:"getDecorator"}),", ",(0,r.jsx)(t.code,{children:"getDecorators"})," and ",(0,r.jsx)(t.code,{children:"getPropertyDecorators"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"roblox-ts-decorators",children:"roblox-ts decorators"}),"\n",(0,r.jsxs)(t.p,{children:["Flamework supports reflection for native roblox-ts decorators using the ",(0,r.jsx)(t.code,{children:"@metadata reflect"})," metadata."]}),"\n",(0,r.jsxs)(t.p,{children:["Unlike Flamework decorators, ",(0,r.jsx)(t.code,{children:"identifier"})," is not generated by default and must be specified under ",(0,r.jsx)(t.code,{children:"@metadata"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"/** @metadata reflect identifier flamework:parameters */\nconst NewDecorator = (ctor: unknown) => {};\n"})}),"\n",(0,r.jsx)(t.h3,{id:"flamework-decorators",children:"Flamework decorators"}),"\n",(0,r.jsx)(t.p,{children:"Flamework has two kinds of decorators, meta decorators and normal decorators."}),"\n",(0,r.jsx)(t.p,{children:"All Flamework decorators add the metadata necessary for the modding API, however, normal decorators also allow you to run a custom function afterwards. This function is passed information about where it was applied as well as the arguments passed into it."}),"\n",(0,r.jsxs)(t.p,{children:["You are also able to define metadata which will be generated when a class uses your decorator as shown in ",(0,r.jsx)(t.a,{href:"../metadata#how-do-i-request-metadata",children:"the metadata docs"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'// Property Decorators\nexport const FieldDecorator = Modding.createMetaDecorator<[string]>("Property");\nexport const FieldDecorator = Modding.createDecorator<[string]>("Property", (descriptor, [name]) => {\n\tprint("Decorated field", descriptor.isStatic, tostring(descriptor.object) + "." + descriptor.property);\n\tprint("Passed in name:", name);\n});\n\n// Method Decorators\nexport const MethodDecorator = Modding.createMetaDecorator<[string]>("Method");\nexport const MethodDecorator = Modding.createDecorator<[string]>("Method", (descriptor, [name]) => {\n\tprint("Decorated method", descriptor.isStatic, tostring(descriptor.object) + "." + descriptor.property + "()");\n\tprint("Passed in name:", name);\n});\n\n// Class Decorators\nexport const NameDecorator = Modding.createMetaDecorator<[string]>("Class");\nexport const NameDecorator = Modding.createDecorator<[string]>("Class", (descriptor, [name]) => {\n\tprint("Decorated object", descriptor.object);\n\tprint("Passed in name:", name);\n});\n\n@NameDecorator("Peter")\nclass A {\n\t@FieldDecorator("John")\n\tpublic abc = 1;\n\n\t@FieldDecorator("Andrew")\n\t@MethodDecorator("Andrew")\n\tpublic method() {}\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"implementing-the-custom-decorators",children:"Implementing the custom decorators"}),"\n",(0,r.jsx)(t.p,{children:"After defining the decorator and any metadata you want it to use, you can use the listeners API to implement it. It's recommended that you implement decorators in a service/controller so that they only occur after ignition."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'@Service()\nexport class MyDecoratorService implements OnStart {\n\tonStart() {\n\t\t// Retrieve all constructors that are using the NameDecorator\n\t\t// You can do whatever you wish with the constructor from here\n\t\t// e.g construct an instance via Flamework\'s dependency resolution\n\t\tconst constructors = Modding.getDecorators<typeof NameDecorator>();\n\t\tfor (const { object, arguments: args } of constructors) {\n\t\t\tprint(object, "is named", args[0]);\n\t\t}\n\n\t\t// Listen for new listeners that are using NameDecorator\n\t\tModding.onListenerAdded<typeof NameDecorator>((object) => {\n\t\t\t// Retrieves the arguments from the decorator\n\t\t\tconst decorator = Modding.getDecorator<typeof NameDecorator>(object);\n\t\t\tif (decorator) {\n\t\t\t\tconst [name] = decorator.arguments;\n\t\t\t\tprint(object, "is the child of", name);\n\t\t\t}\n\n\t\t\t// Retrieves all the FieldDecorators\n\t\t\tfor (const [prop, decorator] of Modding.getPropertyDecorators<typeof FieldDecorator>(object)) {\n\t\t\t\tconst [name] = decorator.arguments;\n\t\t\t\tprint(object, "has prop", prop, "with name", name);\n\t\t\t}\n\t\t});\n\t}\n}\n'})})]})}function m(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1151:(e,t,o)=>{o.d(t,{Z:()=>c,a:()=>s});var r=o(7294);const n={},a=r.createContext(n);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);